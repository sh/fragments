// Generated by CoffeeScript 1.9.1
var _, application, camelSnakeToHyphenColon, camelToHyphen, camelToSnake, colonToSnake, commandNameToKey, fs, getCommandNamesFromLifetime, hinoki, hyphenColonToCamelSnake, hyphenToCamel, init, loadFactories, middleware, path, request, snakeToCamel, snakeToColon, sourcesToFactories, toSources,
  slice = [].slice;

path = require('path');

fs = require('fs');

hinoki = require('hinoki');

_ = require('lodash');

module.exports.loadFactories = loadFactories = function(arg1, arg2) {
  var exp, ext, filenames, filepath, object, stat;
  if (arg2 != null) {
    object = arg1;
    filepath = arg2;
  } else {
    object = {};
    filepath = arg1;
  }
  if ('string' !== typeof filepath) {
    throw new Error("`filepath` argument must be a string but is type = `" + (typeof filepath) + "` value = `" + filepath + "`");
  }
  if ('object' !== typeof object) {
    throw new Error("`object` argument must be a string but is type = `" + (typeof object) + "` value = `" + object + "`");
  }
  stat = fs.statSync(filepath);
  if (stat.isFile()) {
    ext = path.extname(filepath);
    if (ext !== '.js' && ext !== '.coffee') {
      return;
    }
    if (ext === '.coffee') {
      require('coffee-script/register');
    }
    exp = require(filepath);
    Object.keys(exp).map(function(key) {
      if ('function' !== typeof exp[key]) {
        throw new Error('export is not a function: ' + key + ' in :' + filepath);
      }
      if (object[key] != null) {
        throw new Error('duplicate export: ' + key + ' in: ' + filepath + '. first was in: ' + object[key].$file);
      }
      object[key] = exp[key];
      return object[key].$file = filepath;
    });
  } else if (stat.isDirectory()) {
    filenames = fs.readdirSync(filepath);
    filenames.forEach(function(filename) {
      return loadFactories(object, path.join(filepath, filename));
    });
  }
  return object;
};

module.exports.camelToSnake = camelToSnake = function(string) {
  return string.replace(/([a-z][A-Z])/g, function(m) {
    return m[0] + '_' + m[1].toLowerCase();
  });
};

module.exports.snakeToCamel = snakeToCamel = function(string) {
  return string.replace(/_([a-z])/g, function(m) {
    return m[1].toUpperCase();
  });
};

module.exports.camelToHyphen = camelToHyphen = function(string) {
  return string.replace(/([a-z][A-Z])/g, function(m) {
    return m[0] + '-' + m[1].toLowerCase();
  });
};

module.exports.hyphenToCamel = hyphenToCamel = function(string) {
  return string.replace(/-([a-z])/g, function(m) {
    return m[1].toUpperCase();
  });
};

module.exports.colonToSnake = colonToSnake = function(string) {
  return string.replace(/:/g, '_');
};

module.exports.snakeToColon = snakeToColon = function(string) {
  return string.replace(/_/g, ':');
};

module.exports.hyphenColonToCamelSnake = hyphenColonToCamelSnake = function(string) {
  return hyphenToCamel(colonToSnake(string));
};

module.exports.camelSnakeToHyphenColon = camelSnakeToHyphenColon = function(string) {
  return camelToHyphen(snakeToColon(string));
};

module.exports.namespaceResolver = function(name, lifetime, inner) {
  var result;
  result = inner(name);
  if (result != null) {
    return result;
  } else {
    return inner('fragments_' + name);
  }
};

module.exports.COMMAND_PREFIX = 'command_';

module.exports.getCommandNamesFromLifetime = getCommandNamesFromLifetime = function(lifetime) {
  return Object.keys(lifetime.factories).filter(function(x) {
    return x.indexOf(module.exports.COMMAND_PREFIX) === 0;
  }).map(function(x) {
    return x.slice(module.exports.COMMAND_PREFIX.length);
  }).map(camelSnakeToHyphenColon);
};

module.exports.commandNameToKey = commandNameToKey = function(name) {
  return module.exports.COMMAND_PREFIX + hyphenColonToCamelSnake(name);
};

module.exports.runCommand = function() {
  var arg, args, commandFactory, commandKey, commandName, lifetime;
  lifetime = arguments[0], commandName = arguments[1], arg = arguments[2], args = 4 <= arguments.length ? slice.call(arguments, 3) : [];
  if (commandName != null) {
    commandName = commandName.toLowerCase();
  }
  if ((commandName == null) || commandName === 'help') {
    console.log('available commands:');
    return getCommandNamesFromLifetime(lifetime).forEach(function(name) {
      var help, key;
      key = commandNameToKey(name);
      help = lifetime.factories[key].$help;
      return console.log(name + (help ? ' - ' + help : ''));
    });
  } else {
    commandKey = commandNameToKey(commandName);
    commandFactory = lifetime.factories[commandKey];
    if (commandFactory != null) {
      return hinoki.get(lifetime, commandKey).then(function(commandInstance) {
        return commandInstance.apply(null, [arg].concat(slice.call(args)));
      });
    } else {
      throw new Error("unrecognized command: " + commandName);
    }
  }
};

module.exports.toSources = toSources = function(value) {
  if (value == null) {
    return [];
  } else if (Array.isArray(value)) {
    return _.flatten(value);
  } else {
    return [value];
  }
};

module.exports.sourcesToFactories = sourcesToFactories = function(sources, overrideWarnings) {
  var reducer;
  reducer = function(existingFactories, value) {
    var additionalFactories;
    additionalFactories = (function() {
      if ('string' === typeof value) {
        return loadFactories(value);
      } else if ('object' === typeof value) {
        return value;
      } else {
        throw new Error('source must be a filename, directory name or an object');
      }
    })();
    _.each(additionalFactories, function(value, key) {
      if ((overrideWarnings != null) && (existingFactories[key] != null)) {
        overrideWarnings(key, existingFactories[key], value);
      }
      return existingFactories[key] = value;
    });
    return existingFactories;
  };
  return sources.reduce(reducer, {});
};

module.exports.init = init = loadFactories(__dirname + '/init');

module.exports.application = application = loadFactories(__dirname + '/application');

module.exports.request = request = loadFactories(__dirname + '/request');

module.exports.middleware = middleware = loadFactories(__dirname + '/middleware');

_.each(init, function(f) {
  return f.$source = 'fragments.init';
});

_.each(application, function(f) {
  return f.$source = 'fragments.application';
});

_.each(request, function(f) {
  return f.$source = 'fragments.request';
});

_.each(middleware, function(f) {
  return f.$source = 'fragments.middleware';
});

module.exports.configure = function(options) {
  var InitLifetime, factories, shadowWarnings, sources;
  if (options == null) {
    options = {};
  }
  shadowWarnings = options.shadowWarnings != null ? 'function' === typeof options.shadowWarnings ? options.shadowWarnings : module.exports.defaultShadowWarnings : void 0;
  options.overrideWarnings = options.overrideWarnings != null ? 'function' === typeof options.overrideWarnings ? options.overrideWarnings : module.exports.defaultOverrideWarnings : void 0;
  sources = {
    init: toSources(options.init),
    application: toSources(options.application),
    request: toSources(options.request),
    middleware: toSources(options.middleware)
  };
  sources.init.unshift(init);
  sources.application.unshift(application);
  sources.request.unshift(request);
  sources.middleware.unshift(middleware);
  factories = _.mapValues(sources, function(source) {
    return sourcesToFactories(source, options.overrideWarnings);
  });
  if (shadowWarnings != null) {
    _.each(factories.request, function(value, key) {
      if (factories.process[key] != null) {
        return shadowWarnings(key, factories.process[key], value);
      }
    });
    _.each(factories.middleware, function(value, key) {
      if (factories.request[key] != null) {
        shadowWarnings(key, factories.request[key], value);
      }
      if (factories.process[key] != null) {
        return shadowWarnings(key, factories.process[key], value);
      }
    });
  }
  InitLifetime = function() {
    this.values = {
      applicationFactories: factories.application,
      requestFactories: factories.request,
      middlewareFactories: factories.middleware,
      namespaceResolver: module.exports.namespaceResolver
    };
    return this;
  };
  InitLifetime.prototype.factories = factories.init;
  return {
    factory: function(factory) {
      var initLifetime;
      initLifetime = new InitLifetime;
      return hinoki.get(initLifetime, 'applicationLifetime').then(function(applicationLifetime) {
        return hinoki.get(applicationLifetime, 'fragments_APPLICATION');
      }).then(function(APPLICATION) {
        return APPLICATION(factory);
      });
    },
    command: function() {
      var args, initLifetime;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      initLifetime = new InitLifetime;
      return hinoki.get(initLifetime, 'applicationLifetime').then(function(applicationLifetime) {
        var ref;
        return (ref = module.exports).runCommand.apply(ref, [applicationLifetime].concat(slice.call(args)));
      });
    }
  };
};
